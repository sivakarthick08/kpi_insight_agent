import { KNOWLEDGE_BASE_TABLE_NAME } from "../lib/conts";
import { dbClient } from "../../databases/db";

export interface KnowledgeBaseEntryMetadata {
  tenantId: string;
  applicationId: string;
  content: string;
  version: number;
}


// =========================
// Knowledge Base Functions
// =========================

export const getNextVersion = async (
  tenantId: string,
  applicationId: string
): Promise<number> => {
  try {
    const queryResult = await dbClient.executeQuery(
      `SELECT MAX(version) as max_version 
       FROM ${KNOWLEDGE_BASE_TABLE_NAME} 
       WHERE tenant_id = $1 AND application_id = $2`,
      [tenantId, applicationId]
    );

    if (
      !queryResult ||
      queryResult.length === 0 ||
      !queryResult[0].max_version
    ) {
      return 1;
    }

    return (queryResult[0].max_version as number) + 1;
  } catch (error) {
    console.error("Error getting next version:", error);
    return 1;
  }
};

export const storeKnowledgeBase = async ({
  content,
  metadata,
  tenantId,
  applicationId,
}: {
  content: string;
  metadata: any[];
  tenantId: string;
  applicationId: string;
}) => {
  try {
    // Auto-generate version number
    const nextVersion = await getNextVersion(tenantId, applicationId);
    const query = `INSERT INTO 
    ${KNOWLEDGE_BASE_TABLE_NAME}
    (content, metadata, tenant_id, application_id, version) 
    VALUES ('${content}', '${JSON.stringify(metadata)}', '${tenantId}', '${applicationId}', ${nextVersion}) RETURNING id, version`;

    const queryResult = await dbClient.executeQuery(query);

    if (!queryResult || queryResult.length === 0) {
      return {
        result: undefined,
        usage: undefined,
        error: "Failed to store knowledge base entry",
      };
    }

    return {
      result: {
        stored: true,
        knowledgeBaseEntry: queryResult[0],
        autoGeneratedVersion: nextVersion,
      },
      error: undefined,
    };
  } catch (error) {
    console.log("error :", error);
    return {
      result: undefined,
      usage: undefined,
      error: `Failed to store knowledge base entry: ${error}`,
    };
  }
};

export const deleteKnowledgeBase = async ({
  knowledgeBaseId,
  tenantId,
  applicationId,
}: {
  knowledgeBaseId: string;
  tenantId: string;
  applicationId: string;
}) => {
  try {
    const queryResult = await dbClient.executeQuery(
      `DELETE FROM ${KNOWLEDGE_BASE_TABLE_NAME} WHERE id = '${knowledgeBaseId}' AND tenant_id = '${tenantId}' AND application_id = '${applicationId}' RETURNING id`,
      [knowledgeBaseId, tenantId, applicationId]
    );

    if (!queryResult || queryResult.length === 0) {
      return {
        result: undefined,
        usage: undefined,
        error: "Failed to delete knowledge base entry or entry not found",
      };
    }

    return {
      result: {
        deleted: true,
        deletedId: knowledgeBaseId,
      },
      error: undefined,
      usage: undefined,
    };
  } catch (error) {
    return {
      result: undefined,
      usage: undefined,
      error: `Failed to delete knowledge base entry: ${error}`,
    };
  }
};

export const updateKnowledgeBase = async ({
  knowledgeBaseId,
  content,
  metadata,
  tenantId,
  applicationId,
}: {
  knowledgeBaseId: string;
  content: string;
  metadata: any[];
  tenantId: string;
  applicationId: string;
}) => {
  try {
    // First check if the entry exists
    const existingEntry = await dbClient.executeQuery(
      `SELECT id, version FROM ${KNOWLEDGE_BASE_TABLE_NAME} WHERE id = '${knowledgeBaseId}' AND tenant_id = '${tenantId}' AND application_id = '${applicationId}'`
    );

    console.log("existingEntry :", existingEntry);
    if (!existingEntry || existingEntry.length === 0) {
      return {
        result: undefined,
        usage: undefined,
        error: "Knowledge base entry not found",
      };
    }

    // Auto-generate next version number
    const nextVersion = await getNextVersion(tenantId, applicationId);

    // Update the existing entry with new version
    const queryResult = await dbClient.executeQuery(
      `UPDATE ${KNOWLEDGE_BASE_TABLE_NAME} 
       SET content = '${content}', metadata = '${JSON.stringify(metadata)}', version = ${nextVersion}, updated_at = NOW() 
       WHERE id = '${knowledgeBaseId}' AND tenant_id = '${tenantId}' AND application_id = '${applicationId}'
       RETURNING id, version`
    );

    if (!queryResult || queryResult.length === 0) {
      return {
        result: undefined,
        usage: undefined,
        error: "Failed to update knowledge base entry",
      };
    }

    return {
      result: {
        updated: true,
        knowledgeBaseEntry: queryResult[0],
        autoGeneratedVersion: nextVersion,
      },
      error: undefined,
    };
  } catch (error) {
    console.log("error :", error);
    return {
      result: undefined,
      usage: undefined,
      error: `Failed to update knowledge base entry: ${error}`,
    };
  }
};

export const getKnowledgeBase = async ({
  knowledgeBaseId,
  tenantId,
  applicationId,
}: {
  knowledgeBaseId: string;
  tenantId: string;
  applicationId: string;
}) => {
  try {
    const queryResult = await dbClient.executeQuery(
      `SELECT id, content, metadata, version, created_at, updated_at 
       FROM ${KNOWLEDGE_BASE_TABLE_NAME} 
       WHERE id = '${knowledgeBaseId}' AND tenant_id = '${tenantId}' AND application_id = '${applicationId}'`
    );

    if (!queryResult || queryResult.length === 0) {
      return {
        result: undefined,
        usage: undefined,
        error: "Knowledge base entry not found",
      };
    }

    const entry = queryResult[0];

    return {
      result: {
        id: entry.id,
        content: entry.content,
        metadata: entry.metadata,
        version: entry.version,
        createdAt: entry.created_at,
        updatedAt: entry.updated_at,
      },
      error: undefined,
    };
  } catch (error) {
    return {
      result: undefined,
      usage: undefined,
      error: `Failed to retrieve knowledge base entry: ${error}`,
    };
  }
};

export const getLatestKnowledgeBase = async ({
  tenantId,
  applicationId,
}: {
  tenantId: string;
  applicationId: string;
}) => {
  try {
    if (!applicationId) {
      applicationId = "default";
    }

    let filter = `WHERE tenant_id = '${tenantId}' `;

    if (applicationId) {
      filter += `AND application_id = '${applicationId}'`;
    }

    const query = `SELECT id, content, metadata, version, created_at, updated_at 
    FROM ${KNOWLEDGE_BASE_TABLE_NAME} 
    ${filter}
    ORDER BY version DESC, created_at DESC 
    LIMIT 1;`;

    let queryResult = await dbClient.executeQuery(query);

    let entry: any;

    if (!queryResult || queryResult.length === 0) {
      const insertQuery = `INSERT INTO ${KNOWLEDGE_BASE_TABLE_NAME} 
            (content, metadata, tenant_id, application_id, version) 
            VALUES ('', '${JSON.stringify([])}', '${tenantId}', '${applicationId}', 1) RETURNING *`;
      queryResult = await dbClient.executeQuery(insertQuery);
    }

    entry = queryResult[0];

    return {
      result: {
        id: entry.id,
        content: entry.content,
        metadata: entry.metadata,
        version: entry.version,
        createdAt: entry.created_at,
        updatedAt: entry.updated_at,
        isLatest: true,
      },
      error: undefined,
    };
  } catch (error) {
    return {
      result: undefined,
      usage: undefined,
      error: `Failed to retrieve latest knowledge base entry: ${error}`,
    };
  }
};

export const searchKnowledgeBase = async ({
  searchContent,
  tenantId,
  applicationId,
}: {
  searchContent: string;
  tenantId: string;
  applicationId: string;
}) => {
  try {
    const queryResult = await dbClient.executeQuery(
      `SELECT id, content, metadata, version, created_at, updated_at 
       FROM ${KNOWLEDGE_BASE_TABLE_NAME} 
       WHERE tenant_id = ${tenantId} AND application_id = ${applicationId} 
       AND (content ILIKE ${`%${searchContent}%`} OR metadata::text ILIKE ${`%${searchContent}%`})
       ORDER BY version DESC, created_at DESC`
    );

    if (!queryResult || queryResult.length === 0) {
      return {
        result: [],
        error: undefined,
      };
    }

    const entries = queryResult.map((entry) => {
      return {
        id: entry.id,
        content: entry.content,
        metadata: entry.metadata,
        version: entry.version,
        createdAt: entry.created_at,
        updatedAt: entry.updated_at,
      };
    });

    return {
      result: entries,
      error: undefined,
    };
  } catch (error) {
    return {
      result: undefined,
      usage: undefined,
      error: `Failed to search knowledge base: ${error}`,
    };
  }
};
